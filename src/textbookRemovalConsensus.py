from src.genAll import FluxGenerator
import cobra
from src import models, helpers

model = cobra.io.load_json_model("toyModel.json")
startReaction = model.reactions.get_by_id("EX_G6P")
include = {startReaction.id: models.FORWARD, "EX_Pyr": models.REVERSE}
initialExclude = []
fg = FluxGenerator(model, startReaction, include, initialExclude)

# This will keep track of which exclusion sets produced each EFM
efmsGeneratedByExclusionSet = {}
def extra(flux, excludeVal):
    # Get value of the flux's reactions
    efmReactionsVal = helpers.reactionNamesToVal(flux.keys(), fg.reactionVals)
    # Initialise dict if neccesary
    if efmReactionsVal not in efmsGeneratedByExclusionSet:
        efmsGeneratedByExclusionSet[efmReactionsVal] = []
    # Store the generating exclusion set for this flux
    efmsGeneratedByExclusionSet[efmReactionsVal].append(excludeVal)
    
fg.setExtra(extra)

print "Use manual input? (y/n)",
if (raw_input() == "y"):
    fg.useManualInput()
    
print "Max number to generate: (enter -1 for no limit)",
maxCount = int(raw_input())
if maxCount > 0:
    fg.setMaxCount(maxCount)
    
# Run the generator
fg.genAll()

# Convert to counts
efmsGeneratedByCount = {}
for k in efmsGeneratedByExclusionSet:
    efmsGeneratedByCount[k] = len(efmsGeneratedByExclusionSet[k])
    
# Get the most common EFM by finding the entry with the highest value
a = efmsGeneratedByCount
mostCommonEFM = max(a, key = lambda k:a[k])
print "Most common EFM", mostCommonEFM
# Get generating exclusion sets
exclusionSets = efmsGeneratedByExclusionSet[mostCommonEFM]

# Try to exclude each reaction and see what the results are
results = []
for r in model.reactions:
    print "Excluding",r.id
    
    #EFMs generated by removing reaction r
    efmsGenerated = {}
    infeasible = 0
    alreadyExcluded = 0
    # For each exclusion set
    for es in exclusionSets:
        exclude = helpers.reactionValToNames(es, fg.reactionVals)
        # If this exclusion set does not already contain the randomly chosen reaction
        if r.id in exclude:
            alreadyExcluded += 1
        else:
            # Add it and try to find a flux
            exclude.append(r.id)
            flux = models.findEFM(model, include, exclude, 0)
            if flux is None:
                #print "Infeasible"
                infeasible += 1
            else:
                # Increment the count indicating how often this has been found
                efmReactionsVal = fg._reactionNamesToVal(flux.keys())
                #print "Found", efmReactionsVal
                if efmReactionsVal not in efmsGenerated:
                    efmsGenerated[efmReactionsVal] = 0
                efmsGenerated[efmReactionsVal] += 1
                
    # Print statistics
    print "\tInfeasible:", infeasible
    print "\tAlreadyEx:", alreadyExcluded
    print "\tEFMs gen:", efmsGenerated
    egm = 0 # Number of ways most common was generated
    egt = 0 # Total number generated
    if len(efmsGenerated) > 0:
        egm = max(efmsGenerated.values())
        egt = sum(efmsGenerated.values())
    percentMajoriy = 100
    if infeasible > 0 or egt > 0:
        # i.e. not all 'already excluded'
        percentMajority = (float(100*max(infeasible, egm))
                           /(infeasible + egt))
    print "\t% majority:", percentMajority
    results.append((r.id, infeasible, alreadyExcluded, egm, percentMajority))
    
# Output results
with open("removalConsensus.csv", "w") as f:
    # Output header
    f.write("Reaction ID, Infeasible, Already excluded, Freq of most common EFM, %majority\n")
    for r in results:
        s = ""
        # Build string
        for rt in r:
            s += str(rt) + ","
        # Remove last comma and add line ending
        s = s[:-1] + "\n"
        f.write(s)
    print "Results written to removalConsensus.csv"